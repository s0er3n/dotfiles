// Original source: https://github.com/Microsoft/vscode/blob/master/extensions/html-language-features/client/src/tagClosing.ts
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.activateTagClosing = void 0;
const coc_nvim_1 = require("coc.nvim");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
function activateTagClosing(tagProvider, supportedLanguages, configName) {
    const disposables = [];
    coc_nvim_1.workspace.onDidChangeTextDocument((event) => {
        const editor = coc_nvim_1.workspace.getDocument(event.textDocument.uri);
        if (editor) {
            onDidChangeTextDocument(editor.textDocument, event.contentChanges);
        }
    }, null, disposables);
    let isEnabled = false;
    updateEnabledState();
    let timeout = void 0;
    async function updateEnabledState() {
        isEnabled = false;
        const editor = await coc_nvim_1.workspace.document;
        if (!editor) {
            return;
        }
        const document = editor.textDocument;
        if (!supportedLanguages[document.languageId]) {
            return;
        }
        if (!coc_nvim_1.workspace.getConfiguration(void 0, document.uri).get(configName)) {
            return;
        }
        isEnabled = true;
    }
    async function onDidChangeTextDocument(document, changes) {
        var _a;
        if (!isEnabled) {
            return;
        }
        const activeEditor = await coc_nvim_1.workspace.document;
        const activeDocument = activeEditor === null || activeEditor === void 0 ? void 0 : activeEditor.textDocument;
        if (document !== activeDocument || changes.length === 0) {
            return;
        }
        if (typeof timeout !== 'undefined') {
            clearTimeout(timeout);
        }
        const lastChange = changes[changes.length - 1];
        const lastCharacter = lastChange.text[lastChange.text.length - 1];
        if (('range' in lastChange && ((_a = lastChange.rangeLength) !== null && _a !== void 0 ? _a : 0) > 0) ||
            (lastCharacter !== '>' && lastCharacter !== '/')) {
            return;
        }
        const rangeStart = 'range' in lastChange
            ? lastChange.range.start
            : vscode_languageserver_protocol_1.Position.create(0, document.getText().length);
        const version = document.version;
        timeout = setTimeout(async () => {
            const position = vscode_languageserver_protocol_1.Position.create(rangeStart.line, rangeStart.character + lastChange.text.length);
            const text = await tagProvider(document, position);
            if (text && isEnabled) {
                const activeEditor = await coc_nvim_1.workspace.document;
                if (activeEditor) {
                    const activeDocument = activeEditor.textDocument;
                    if (document === activeDocument && activeDocument.version === version) {
                        coc_nvim_1.snippetManager.insertSnippet(text, false, {
                            start: position,
                            end: vscode_languageserver_protocol_1.Position.create(position.line, position.character),
                        });
                    }
                }
            }
            timeout = void 0;
        }, 100);
    }
    return {
        dispose: () => {
            disposables.forEach((disposable) => {
                disposable.dispose();
            });
        },
    };
}
exports.activateTagClosing = activateTagClosing;
//# sourceMappingURL=autoClose.js.map
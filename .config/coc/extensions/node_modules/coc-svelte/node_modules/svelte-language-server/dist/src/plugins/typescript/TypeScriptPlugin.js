"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScriptPlugin = void 0;
const typescript_1 = __importDefault(require("typescript"));
const vscode_languageserver_1 = require("vscode-languageserver");
const documents_1 = require("../../lib/documents");
const utils_1 = require("../../utils");
const CodeActionsProvider_1 = require("./features/CodeActionsProvider");
const CompletionProvider_1 = require("./features/CompletionProvider");
const DiagnosticsProvider_1 = require("./features/DiagnosticsProvider");
const FindReferencesProvider_1 = require("./features/FindReferencesProvider");
const getDirectiveCommentCompletions_1 = require("./features/getDirectiveCommentCompletions");
const HoverProvider_1 = require("./features/HoverProvider");
const RenameProvider_1 = require("./features/RenameProvider");
const SelectionRangeProvider_1 = require("./features/SelectionRangeProvider");
const SemanticTokensProvider_1 = require("./features/SemanticTokensProvider");
const SignatureHelpProvider_1 = require("./features/SignatureHelpProvider");
const UpdateImportsProvider_1 = require("./features/UpdateImportsProvider");
const utils_2 = require("./features/utils");
const SnapshotManager_1 = require("./SnapshotManager");
const utils_3 = require("./utils");
class TypeScriptPlugin {
    constructor(configManager, lsAndTsDocResolver) {
        this.configManager = configManager;
        this.lsAndTsDocResolver = lsAndTsDocResolver;
        this.completionProvider = new CompletionProvider_1.CompletionsProviderImpl(this.lsAndTsDocResolver);
        this.codeActionsProvider = new CodeActionsProvider_1.CodeActionsProviderImpl(this.lsAndTsDocResolver, this.completionProvider);
        this.updateImportsProvider = new UpdateImportsProvider_1.UpdateImportsProviderImpl(this.lsAndTsDocResolver);
        this.diagnosticsProvider = new DiagnosticsProvider_1.DiagnosticsProviderImpl(this.lsAndTsDocResolver);
        this.renameProvider = new RenameProvider_1.RenameProviderImpl(this.lsAndTsDocResolver);
        this.hoverProvider = new HoverProvider_1.HoverProviderImpl(this.lsAndTsDocResolver);
        this.findReferencesProvider = new FindReferencesProvider_1.FindReferencesProviderImpl(this.lsAndTsDocResolver);
        this.selectionRangeProvider = new SelectionRangeProvider_1.SelectionRangeProviderImpl(this.lsAndTsDocResolver);
        this.signatureHelpProvider = new SignatureHelpProvider_1.SignatureHelpProviderImpl(this.lsAndTsDocResolver);
        this.semanticTokensProvider = new SemanticTokensProvider_1.SemanticTokensProviderImpl(this.lsAndTsDocResolver);
    }
    async getDiagnostics(document, cancellationToken) {
        if (!this.featureEnabled('diagnostics')) {
            return [];
        }
        return this.diagnosticsProvider.getDiagnostics(document, cancellationToken);
    }
    async doHover(document, position) {
        if (!this.featureEnabled('hover')) {
            return null;
        }
        return this.hoverProvider.doHover(document, position);
    }
    async getDocumentSymbols(document, cancellationToken) {
        if (!this.featureEnabled('documentSymbols')) {
            return [];
        }
        const { lang, tsDoc } = await this.getLSAndTSDoc(document);
        const fragment = await tsDoc.getFragment();
        if (cancellationToken === null || cancellationToken === void 0 ? void 0 : cancellationToken.isCancellationRequested) {
            return [];
        }
        const navTree = lang.getNavigationTree(tsDoc.filePath);
        const symbols = [];
        collectSymbols(navTree, undefined, (symbol) => symbols.push(symbol));
        const topContainerName = symbols[0].name;
        return (symbols
            .slice(1)
            .map((symbol) => {
            if (symbol.containerName === topContainerName) {
                return { ...symbol, containerName: 'script' };
            }
            return symbol;
        })
            .map((symbol) => documents_1.mapSymbolInformationToOriginal(fragment, symbol))
            // Due to svelte2tsx, there will also be some symbols that are unmapped.
            // Filter those out to keep the lsp from throwing errors.
            // Also filter out transformation artifacts
            .filter((symbol) => symbol.location.range.start.line >= 0 &&
            symbol.location.range.end.line >= 0 &&
            !symbol.name.startsWith('__sveltets_'))
            .map((symbol) => {
            if (symbol.name !== '<function>') {
                return symbol;
            }
            let name = documents_1.getTextInRange(symbol.location.range, document.getText()).trimLeft();
            if (name.length > 50) {
                name = name.substring(0, 50) + '...';
            }
            return {
                ...symbol,
                name
            };
        }));
        function collectSymbols(tree, container, cb) {
            const start = tree.spans[0];
            const end = tree.spans[tree.spans.length - 1];
            if (start && end) {
                cb(vscode_languageserver_1.SymbolInformation.create(tree.text, utils_3.symbolKindFromString(tree.kind), vscode_languageserver_1.Range.create(fragment.positionAt(start.start), fragment.positionAt(end.start + end.length)), fragment.getURL(), container));
            }
            if (tree.childItems) {
                for (const child of tree.childItems) {
                    collectSymbols(child, tree.text, cb);
                }
            }
        }
    }
    async getCompletions(document, position, completionContext, cancellationToken) {
        if (!this.featureEnabled('completions')) {
            return null;
        }
        const tsDirectiveCommentCompletions = getDirectiveCommentCompletions_1.getDirectiveCommentCompletions(position, document, completionContext);
        const completions = await this.completionProvider.getCompletions(document, position, completionContext, cancellationToken);
        if (completions && tsDirectiveCommentCompletions) {
            return vscode_languageserver_1.CompletionList.create(completions.items.concat(tsDirectiveCommentCompletions.items), completions.isIncomplete);
        }
        return completions !== null && completions !== void 0 ? completions : tsDirectiveCommentCompletions;
    }
    async resolveCompletion(document, completionItem, cancellationToken) {
        return this.completionProvider.resolveCompletion(document, completionItem, cancellationToken);
    }
    async getDefinitions(document, position) {
        if (!this.featureEnabled('definitions')) {
            return [];
        }
        const { lang, tsDoc } = await this.getLSAndTSDoc(document);
        const mainFragment = await tsDoc.getFragment();
        const defs = lang.getDefinitionAndBoundSpan(tsDoc.filePath, mainFragment.offsetAt(mainFragment.getGeneratedPosition(position)));
        if (!defs || !defs.definitions) {
            return [];
        }
        const docs = new utils_2.SnapshotFragmentMap(this.lsAndTsDocResolver);
        docs.set(tsDoc.filePath, { fragment: mainFragment, snapshot: tsDoc });
        const result = await Promise.all(defs.definitions.map(async (def) => {
            const { fragment, snapshot } = await docs.retrieve(def.fileName);
            if (utils_2.isNoTextSpanInGeneratedCode(snapshot.getFullText(), def.textSpan)) {
                return vscode_languageserver_1.LocationLink.create(utils_1.pathToUrl(def.fileName), utils_3.convertToLocationRange(fragment, def.textSpan), utils_3.convertToLocationRange(fragment, def.textSpan), utils_3.convertToLocationRange(mainFragment, defs.textSpan));
            }
        }));
        return result.filter(utils_1.isNotNullOrUndefined);
    }
    async prepareRename(document, position) {
        if (!this.featureEnabled('rename')) {
            return null;
        }
        return this.renameProvider.prepareRename(document, position);
    }
    async rename(document, position, newName) {
        if (!this.featureEnabled('rename')) {
            return null;
        }
        return this.renameProvider.rename(document, position, newName);
    }
    async getCodeActions(document, range, context, cancellationToken) {
        if (!this.featureEnabled('codeActions')) {
            return [];
        }
        return this.codeActionsProvider.getCodeActions(document, range, context, cancellationToken);
    }
    async executeCommand(document, command, args) {
        if (!this.featureEnabled('codeActions')) {
            return null;
        }
        return this.codeActionsProvider.executeCommand(document, command, args);
    }
    async updateImports(fileRename) {
        if (!(this.configManager.enabled('svelte.enable') &&
            this.configManager.enabled('svelte.rename.enable'))) {
            return null;
        }
        return this.updateImportsProvider.updateImports(fileRename);
    }
    async findReferences(document, position, context) {
        if (!this.featureEnabled('findReferences')) {
            return null;
        }
        return this.findReferencesProvider.findReferences(document, position, context);
    }
    async onWatchFileChanges(onWatchFileChangesParas) {
        let doneUpdateProjectFiles = false;
        for (const { fileName, changeType } of onWatchFileChangesParas) {
            const pathParts = fileName.split(/\/|\\/);
            const dirPathParts = pathParts.slice(0, pathParts.length - 1);
            if (SnapshotManager_1.ignoredBuildDirectories.some((dir) => dirPathParts.includes(dir))) {
                continue;
            }
            const scriptKind = utils_3.getScriptKindFromFileName(fileName);
            if (scriptKind === typescript_1.default.ScriptKind.Unknown) {
                // We don't deal with svelte files here
                continue;
            }
            if (changeType === vscode_languageserver_1.FileChangeType.Created && !doneUpdateProjectFiles) {
                doneUpdateProjectFiles = true;
                await this.lsAndTsDocResolver.updateProjectFiles();
            }
            else if (changeType === vscode_languageserver_1.FileChangeType.Deleted) {
                await this.lsAndTsDocResolver.deleteSnapshot(fileName);
            }
            else {
                await this.lsAndTsDocResolver.updateExistingTsOrJsFile(fileName);
            }
        }
    }
    async updateTsOrJsFile(fileName, changes) {
        await this.lsAndTsDocResolver.updateExistingTsOrJsFile(fileName, changes);
    }
    async getSelectionRange(document, position) {
        if (!this.featureEnabled('selectionRange')) {
            return null;
        }
        return this.selectionRangeProvider.getSelectionRange(document, position);
    }
    async getSignatureHelp(document, position, context, cancellationToken) {
        if (!this.featureEnabled('signatureHelp')) {
            return null;
        }
        return this.signatureHelpProvider.getSignatureHelp(document, position, context, cancellationToken);
    }
    async getSemanticTokens(textDocument, range, cancellationToken) {
        if (!this.featureEnabled('semanticTokens')) {
            return {
                data: []
            };
        }
        return this.semanticTokensProvider.getSemanticTokens(textDocument, range, cancellationToken);
    }
    async getLSAndTSDoc(document) {
        return this.lsAndTsDocResolver.getLSAndTSDoc(document);
    }
    /**
     * @internal Public for tests only
     */
    getSnapshotManager(fileName) {
        return this.lsAndTsDocResolver.getSnapshotManager(fileName);
    }
    featureEnabled(feature) {
        return (this.configManager.enabled('typescript.enable') &&
            this.configManager.enabled(`typescript.${feature}.enable`));
    }
}
exports.TypeScriptPlugin = TypeScriptPlugin;
//# sourceMappingURL=TypeScriptPlugin.js.map
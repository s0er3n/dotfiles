"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findContainingNode = exports.isAfterSvelte2TsxPropsReturn = exports.SnapshotFragmentMap = exports.isPartOfImportStatement = exports.isNoTextSpanInGeneratedCode = exports.isInGeneratedCode = exports.isComponentAtPosition = exports.getComponentAtPosition = void 0;
const documents_1 = require("../../../lib/documents");
const ComponentInfoProvider_1 = require("../ComponentInfoProvider");
/**
 * If the given original position is within a Svelte starting tag,
 * return the snapshot of that component.
 */
async function getComponentAtPosition(lang, doc, tsDoc, originalPosition) {
    var _a;
    if (tsDoc.parserError) {
        return null;
    }
    if (documents_1.isInTag(originalPosition, doc.scriptInfo) ||
        documents_1.isInTag(originalPosition, doc.moduleScriptInfo)) {
        // Inside script tags -> not a component
        return null;
    }
    const node = documents_1.getNodeIfIsInComponentStartTag(doc.html, doc.offsetAt(originalPosition));
    if (!node) {
        return null;
    }
    const fragment = await tsDoc.getFragment();
    const generatedPosition = fragment.getGeneratedPosition(doc.positionAt(node.start + 1));
    const def = (_a = lang.getDefinitionAtPosition(tsDoc.filePath, fragment.offsetAt(generatedPosition))) === null || _a === void 0 ? void 0 : _a[0];
    if (!def) {
        return null;
    }
    return ComponentInfoProvider_1.JsOrTsComponentInfoProvider.create(lang, def);
}
exports.getComponentAtPosition = getComponentAtPosition;
function isComponentAtPosition(doc, tsDoc, originalPosition) {
    if (tsDoc.parserError) {
        return false;
    }
    if (documents_1.isInTag(originalPosition, doc.scriptInfo) ||
        documents_1.isInTag(originalPosition, doc.moduleScriptInfo)) {
        // Inside script tags -> not a component
        return false;
    }
    return !!documents_1.getNodeIfIsInComponentStartTag(doc.html, doc.offsetAt(originalPosition));
}
exports.isComponentAtPosition = isComponentAtPosition;
/**
 * Checks if this a section that should be completely ignored
 * because it's purely generated.
 */
function isInGeneratedCode(text, start, end) {
    const lineStart = text.lastIndexOf('\n', start);
    const lineEnd = text.indexOf('\n', end);
    const lastStart = text.substring(lineStart, start).lastIndexOf('/*Ωignore_startΩ*/');
    const lastEnd = text.substring(lineStart, start).lastIndexOf('/*Ωignore_endΩ*/');
    return lastStart > lastEnd && text.substring(end, lineEnd).includes('/*Ωignore_endΩ*/');
}
exports.isInGeneratedCode = isInGeneratedCode;
/**
 * Checks that this isn't a text span that should be completely ignored
 * because it's purely generated.
 */
function isNoTextSpanInGeneratedCode(text, span) {
    return !isInGeneratedCode(text, span.start, span.start + span.length);
}
exports.isNoTextSpanInGeneratedCode = isNoTextSpanInGeneratedCode;
function isPartOfImportStatement(text, position) {
    const line = documents_1.getLineAtPosition(position, text);
    return /\s*from\s+["'][^"']*/.test(line.substr(0, position.character));
}
exports.isPartOfImportStatement = isPartOfImportStatement;
class SnapshotFragmentMap {
    constructor(resolver) {
        this.resolver = resolver;
        this.map = new Map();
    }
    set(fileName, content) {
        this.map.set(fileName, content);
    }
    get(fileName) {
        return this.map.get(fileName);
    }
    getFragment(fileName) {
        var _a;
        return (_a = this.map.get(fileName)) === null || _a === void 0 ? void 0 : _a.fragment;
    }
    async retrieve(fileName) {
        let snapshotFragment = this.get(fileName);
        if (!snapshotFragment) {
            const snapshot = await this.resolver.getSnapshot(fileName);
            const fragment = await snapshot.getFragment();
            snapshotFragment = { fragment, snapshot };
            this.set(fileName, snapshotFragment);
        }
        return snapshotFragment;
    }
    async retrieveFragment(fileName) {
        return (await this.retrieve(fileName)).fragment;
    }
}
exports.SnapshotFragmentMap = SnapshotFragmentMap;
function isAfterSvelte2TsxPropsReturn(text, end) {
    const textBeforeProp = text.substring(0, end);
    // This is how svelte2tsx writes out the props
    if (textBeforeProp.includes('\nreturn { props: {')) {
        return true;
    }
}
exports.isAfterSvelte2TsxPropsReturn = isAfterSvelte2TsxPropsReturn;
function findContainingNode(node, textSpan, predicate) {
    const children = node.getChildren();
    const end = textSpan.start + textSpan.length;
    for (const child of children) {
        if (!(child.getStart() <= textSpan.start && child.getEnd() >= end)) {
            continue;
        }
        if (predicate(child)) {
            return child;
        }
        const foundInChildren = findContainingNode(child, textSpan, predicate);
        if (foundInChildren) {
            return foundInChildren;
        }
    }
}
exports.findContainingNode = findContainingNode;
//# sourceMappingURL=utils.js.map